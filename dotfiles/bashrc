# According to:
# http://superuser.com/questions/789448/choosing-between-bashrc-profile-bash-profile-etc
#
#   * ~/.bashrc has anything you'd want at an interactive command line.
#     Command prompt, EDITOR variable, bash aliases for my use
#   * ~/.bashrc must not output anything

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

#
# Prompt
#

if [ -f ~/.emoji_vars.sh ]; then
    source ~/.emoji_vars.sh
fi

if [ -f ~/.emoji-prompt.sh ]; then
    source ~/.emoji-prompt.sh
fi

# don't put duplicate lines in the history. See bash(1) for more options
export HISTCONTROL=ignoredups

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(lesspipe)"

#
# Include private defs (not in main file cuz this one's in my public github).
#
if [ -f "$HOME/.private_bashrc" ]; then
    source $HOME/.private_bashrc
fi

if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
        . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
        . /etc/bash_completion
    fi

    if [ -f /etc/profile.d/bash_completion.sh ]; then
        source /etc/profile.d/bash_completion.sh
    fi

    # Homebrew's completions
    if [[ $(which brew) != "" && -f $(brew --prefix)/etc/bash_completion ]]; then
        source $(brew --prefix)/etc/bash_completion
    fi

    # Take in all the custom completions too.
    if [ -d ~/.bash_completion.d ]; then
        for F in $(ls ~/.bash_completion.d/*.bash); do
            source $F
        done
    fi

    # Ugh, manual completions
    if [[ $(which aws_completer) != "" ]]; then
        complete -C aws_completer aws
    fi
fi

# OS X specific confs
if [ $(uname) = "Darwin" ] ; then
   alias ls='ls -G'


    # gnu sed on osx
    export PATH="/usr/local/opt/gnu-sed/libexec/gnubin:$PATH"

    # Colorize the Terminal for Mac
    export CLICOLOR=1;
else
   alias ls='ls --color'
fi

alias screen="screen -T xterm-color"

# General Go
# MY_GOPATH='$(echo $PWD | sed "s:\($HOME/src/[^/]*/[^/]*\)/src/.*:\1:"):~/go/test'
# alias set_my_gopath="export GOPATH=$MY_GOPATH"
# alias gogrep='grep -IR --include "*.go" --exclude-dir "vendor" --exclude-dir ".vendor_for_old" --exclude-dir "Godeps" --exclude-dir ".git"'
# alias gotest='~/go/test/bin/ginkgo -notify -race --randomizeAllSpecs -p'
# alias gomake='make -f $HOME/.golang.Makefile'
# gorun() { gomake RUN_ARGS="$*" run ;}

# Postgres DB
# alias pgstart='/usr/local/bin/postgres -D $PG_DATA_DIR -r /usr/local/var/postgres/server.log'

# Node / io.js / nvm shit
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

if [[ $(which brew) != "" && -f "$(brew --prefix)/opt/bash-git-prompt/share/gitprompt.sh" ]]; then
    source "$(brew --prefix)/opt/bash-git-prompt/share/gitprompt.sh"

    # Don't fetch remote every prompt!
    export GIT_PROMPT_FETCH_REMOTE_STATUS=0
elif [[ -f "$HOME/.bash-git-prompt/gitprompt.sh" ]]; then
    source "$HOME/.bash-git-prompt/gitprompt.sh"

    # Don't fetch remote every prompt!
    export GIT_PROMPT_FETCH_REMOTE_STATUS=0
else
    if [ -f "$HOME/.bash/git-aware-prompt/main.sh" ]; then
        export GITAWAREPROMPT="$HOME/.bash/git-aware-prompt"
        source $GITAWAREPROMPT/main.sh
    fi

    rand() {
        echo $((  $1 *  RANDOM  / 32767   ))
    }

    rand_element () {
        local -a th=(x "$@")
        unset th[0]
        echo "${th[$(($(rand "${#th[*]}")+1))]}"
    }

    # Emoji in prompt!!!
    starts="🌊 ⚡️ ☁️ ⭐️ 🌚 🌝 🌞 🌜 🌍 🌵 🌴 🍄 🎃 💻 📺 🛀 🚽 🛁 🎨 🎬 🎤 🎧 🎶 🎵 👾 🎲 ⚽️ 🏀 🏈 🚴 🏇 🏊 🏄 🏂 ☕️ 🍵 🍺 🍷 🍸 🍕 🍔 🍟 🍣 🍱 🍙 🍜 🍳 🍦 🍧 🍰 🍭 🍒 🍋 🍉 🍑 🍌 🍍 🍆 🏩 🌇 🌆 🏯 🏰 ⛺️ 🌄 🌅 🗽 🌃 🌉 🎢 ⛵️ 🚀 ✈️ 🚁 🚎 🚌 🚕 🚛 🚲 "
    endings="🐶 🐺 🐱 🐭 🐹 🐰 🐸 🐯 🐨 🐻 🐷 🐮 🐗 🐵 🐒 🐴 🐑 🐘 🐼 🐧 🐦 🐤 🐥 🐣 🐔 🐍 🐢 🐛 🐝 🐜 🐞 🐌 🐙 🐠 🐟 🐬 🐳 🐋 🐄 🐏 🐀 🐃 🐅 🐇 🐉 🐎 🐐 🐓 🐕 🐖 🐁 🐂 🐲 🐡 🐊 🐫 🐪 🐆 🐈 🐩 ⛄️ 🙈 🙉 🙊 💀 👽 💩 👾 👻 🎅"

    # set a fancy prompt (non-color, unless we know we "want" color)
    color_prompt="\[$bldgrn\]\u@\h\[$txtrst\]:\[$bldblu\]\w\[$txtrst\] \[$txtcyn\]\$git_branch\[$txtred\]\$git_dirty\[$txtrst\]"
    case "$TERM" in
    xterm-color|xterm-256color)
        export PS1="$color_prompt"
        ;;
    xterm)
        export PS1="$color_prompt"
        ;;
    screen)
        export PS1="$color_prompt"
        ;;
    *)
        export PS1='\u@\h:\w'
        ;;
    esac

#    function __prompt_command() {
#        local EXIT="$?"             # This needs to be first
#
#        # Need to call the git branch and dirty fns ourselves, so exit code remains
#        # clean.
#        if [ -f "$HOME/.bash/git-aware-prompt/main.sh" ]; then
#            find_git_branch
#            find_git_dirty
#        fi
#
#        local RCol='\[\e[0m\]'
#
#        local Red='\[\e[0;31m\]'
#        local Gre='\[\e[0;32m\]'
#        local BYel='\[\e[1;33m\]'
#        local BBlu='\[\e[1;34m\]'
#        local Pur='\[\e[0;35m\]'
#        local Blk='\[\e[0;30m\]'
#
#        local EXIT_STATE=""
#        if [ $EXIT != 0 ]; then
#            EXIT_STATE="${Red}^-- $EXIT${RCol} "
#        fi
#
#        local EMOJI_START=""
#        local EMOJI_END="$"
#        if [ $(uname -s) == "Darwin" ]; then
#            EMOJI_START="$(rand_element $starts) "
#            EMOJI_END=" $(rand_element $endings)${Blk}¸${RCol}"
#        fi
#
#        local USER_HOST="${Gre}\u${RCol}@${BBlu}\h${RCol}"
#        local DIR_PATH="${BBlu}\w${RCol}"
#
#        local GIT_STATE=""
#        if [ -f "$HOME/.bash/git-aware-prompt" ]; then
#            GIT_STATE="${Pur}\$git_branch${Red}\$git_dirty${RCol}"
#        fi
#
#        PS1="$EMOJI_START$EXIT_STATE$USER_HOST:$DIR_PATH $GIT_STATE$EMOJI_END "
#    }
#    export PROMPT_COMMAND="__prompt_command"
fi
